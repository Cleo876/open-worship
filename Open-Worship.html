<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenWorship v2.5.0</title>
    <script>
        const TOOL_VERSION = '2.5.0';
        const GITHUB_SOURCE_URL = 'https://raw.githubusercontent.com/Cleo876/open-worship/refs/heads/main/Open-Worship.html';
        const DOWNLOAD_PAGE_URL = 'https://cleo876.github.io/open-worship/';
    </script>
    
    <!-- PRE-LOAD FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&family=Oswald:wght@400;700&family=Poppins:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* CORE VARIABLES */
        :root {
            --bg-dark: #121212;
            --bg-panel: #1e1e1e;
            --bg-header: #2d2d2d;
            --accent: #007acc;
            --text-main: #e0e0e0;
            --border: #333;
        }

        body {
            margin: 0;
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- UI COMPONENTS --- */
        .menu-bar {
            height: 28px; background: #1a1a1a; display: flex; align-items: center; 
            padding: 0 12px; font-size: 0.8rem; border-bottom: 1px solid #333; gap: 5px; user-select: none;
        }
        .menu-item { padding: 4px 10px; cursor: default; color: #bbb; position: relative; border-radius: 4px; }
        .menu-item:hover, .menu-item.active { background: #333; color: white; }
        .dropdown { display: none; position: absolute; top: 100%; left: 0; background: #2a2a2a; border: 1px solid #444; min-width: 200px; z-index: 500; box-shadow: 0 4px 10px rgba(0,0,0,0.5); padding: 4px 0; border-radius: 4px; }
        .menu-item.active .dropdown { display: block; }
        .dropdown div { padding: 6px 20px; color: #ddd; }
        .dropdown div:hover { background: var(--accent); }
        .separator { height:1px; background:#444; margin:4px 0; }

        /* HEADER */
        header {
            min-height: 50px; height: auto;
            background: var(--bg-header); border-bottom: 1px solid var(--border);
            display: flex; align-items: center; padding: 5px 16px; justify-content: space-between; gap: 20px;
            flex-wrap: wrap; 
        }
        .brand { font-weight: bold; font-size: 1.1rem; color: #f0f0f0; display:flex; align-items:center; gap:10px; white-space: nowrap; flex-shrink: 0; }
        .brand-badge { font-size: 0.65em; background: #151515; padding: 3px 10px; border-radius: 25px; border: 1px solid #333; }
        
        .controls { 
            display: flex; gap: 10px; align-items: center; 
            flex-wrap: wrap; justify-content: flex-end; flex: 1;
        }

        button {
            background: linear-gradient(to bottom, #3a3a3a, #2b2b2b); border: 1px solid #444; color: #f0f0f0;
            padding: 0 16px; border-radius: 6px; cursor: pointer; height: 24px; font-weight:600; font-size:0.8rem;
            white-space: nowrap;
        }
        button:hover { background: #444; border-color: #666; }
        button.live-btn { background: linear-gradient(to bottom, #d32f2f, #b71c1c); border-color: #b71c1c; }
        button.live-btn:hover { background: #f44336; }
        button.active-state { background: var(--accent); border-color: #005f9e; }
        
        /* Specific styling for fullscreen button on the menu bar */
        .btn-toggle-fullscreen {
            padding: 0 8.5px;
            font-size: 0.85rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 27px;
            margin-left: 5px;
        }


        /* --- LAYOUT --- */
        .app-body { display: flex; flex-direction: column; flex: 1; height: calc(100vh - 78px); }
        .top-section { display: flex; flex: 1; min-height: 0; }
        
        .panel { display:flex; flex-direction:column; }
        .panel-left { width: 250px; background: var(--bg-panel); border-right: 1px solid var(--border); resize: horizontal; overflow:auto; }
        .panel-center { flex: 1; background: #111; padding: 20px; overflow-y: auto; display: flex; flex-wrap: wrap; align-content: flex-start; gap: 15px; justify-content: center; }
        .panel-right { width: 300px; background: black; border-left: 1px solid var(--border); padding: 15px; align-items: center; }
        
        .panel-header { padding: 8px 12px; background: linear-gradient(to right, #252525, #222); font-size: 0.75rem; font-weight: bold; color: #888; border-bottom: 1px solid var(--border); text-transform: uppercase; letter-spacing: 0.5px; }
        
        /* SCHEDULE & LIBRARY */
        .schedule-container { flex: 1; overflow-y: auto; min-height: 50px; }
        .schedule-container.drag-over { background: rgba(0, 122, 204, 0.1); }
        
        .schedule-item { 
            padding: 10px 12px; 
            border-bottom: 1px solid #2a2a2a; 
            cursor: default; 
            display: flex; 
            font-size: 0.9rem; 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .schedule-item:hover { background: #333; }
        .schedule-item.selected { background: var(--accent); color: white; border-left: 3px solid #66b2ff; }
        .schedule-item.dragging { opacity: 0.5; background: #444; border: 1px dashed #666; }

        .bottom-section { height: 300px; background: var(--bg-panel); border-top: 1px solid var(--border); display: flex; flex-direction: column; }
        .library-tabs { display: flex; background: #252525; border-bottom: 1px solid var(--border); align-items: center; }
        .tab { padding: 8px 20px; cursor: pointer; color: #888; border-right: 1px solid #333; }
        .tab.active { background: var(--bg-panel); color: var(--accent); font-weight: bold; border-bottom: 2px solid var(--accent); }
        
        .library-content { 
            flex: 1; 
            display: flex; 
            position: relative; 
            overflow: hidden; /* Changed from relative to hidden to contain scrolling */
        } 
        
        /* NEW: Tab-specific library containers */
        .library-list-container {
            flex: 1;
            display: none; /* Hidden by default */
            flex-direction: column;
            height: 100%;
            position: relative;
        }
        
        .library-list-container.active {
            display: flex;
        }
        
        .library-list {
            flex: 1;
            overflow-y: auto;
            border-right: 1px solid var(--border);
            position: relative;
        }
        
        /* FLOATING ADD BUTTON */
        .fab-add {
            position: absolute; bottom: 20px; right: 420px;
            width: 40px; height: 40px; border-radius: 50%; border: none;
            background: var(--accent); color: white; font-size: 24px; font-weight: bold;
            display: none; align-items: center; justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; z-index: 100;
            transition: transform 0.2s, background 0.2s;
        }
        .fab-add:hover { transform: scale(1.1); background: #005f9e; }

        .preview-pane-wrapper { width: 400px; display: flex; flex-direction: column; border-left: 1px solid #222; background: #1a1a1a; }
        
        /* LIBRARY PREVIEW CONTAINERS */
        .library-preview-container {
            flex: 1;
            background: #181818;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }
        
        /* CANVAS (Visual Preview) */
        canvas.library-preview-canvas {
            width: 100%;
            aspect-ratio: 16/9;
            background: black;
            border: 1px solid #333;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        
        /* TEXT AREA (Scripture Preview) */
        #libraryPreviewText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            background: #181818;
            color: #ddd;
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            overflow-y: auto;
            white-space: pre-wrap;
            display: none;
        }
        
        /* PREVIEW CARDS */
        .slide-wrapper { transition: transform 0.1s; cursor: pointer; }
        .slide-wrapper:hover { transform: scale(1.03); }
        .slide-wrapper.active canvas { border-color: #d32f2f; box-shadow: 0 0 20px rgba(211,47,47,0.6); }
        canvas.preview-canvas { background: black; border: 2px solid #333; border-radius: 4px; width: 200px; aspect-ratio: 16/9; object-fit: contain; }
        canvas.live-monitor { 
            width: 100%; aspect-ratio: 16/9; border: 2px solid #444; background: black; border-radius: 4px;
            transition: opacity 0.3s ease;
        }
        canvas.live-monitor.fading { opacity: 0; }

        /* --- MODALS --- */
        .modal-overlay { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center; }
        .editor-window { width: 90vw; height: 90vh; background: #222; border: 1px solid #444; display: flex; flex-direction: column; border-radius: 8px; box-shadow: 0 0 50px rgba(0,0,0,0.5); }
        .editor-header { padding: 10px 15px; background: #333; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center; }
        .editor-body { display: flex; flex: 1; overflow: hidden; }
        .editor-sidebar { width: 200px; background: #1a1a1a; border-right: 1px solid #444; overflow-y: auto; display: flex; flex-direction: column; }
        .slide-thumb { padding: 10px; border-bottom: 1px solid #333; cursor: pointer; opacity: 0.7; display:flex; gap:10px; align-items:center; }
        .slide-thumb:hover { opacity: 1; background: #252525; }
        .slide-thumb.active { opacity: 1; background: var(--accent); color: white; }
        .thumb-num { font-weight: bold; font-size: 1.2rem; opacity: 0.5; }
        .editor-main { flex: 1; display: flex; flex-direction: column; background: #151515; }
        .editor-preview-area { flex: 1; display: flex; align-items: center; justify-content: center; background: #111; padding: 20px; overflow: hidden; position: relative; }
        .editor-canvas { width: 70%; aspect-ratio: 16/9; background: black; border: 1px solid #555; box-shadow: 0 0 20px rgba(0,0,0,0.5); cursor: default; }
        .editor-toolbar { padding: 8px; background: #252525; border-top: 1px solid #444; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .tool-group { display: flex; gap: 5px; border-right: 1px solid #444; padding-right: 10px; align-items: center; }
        .tool-input { background: #111; border: 1px solid #444; color: white; padding: 4px; border-radius: 4px; }
        .tool-btn { width: 30px; padding: 0; }
        .tool-label { font-size: 0.7rem; color: #888; margin-right: 5px; }
        .editor-text-input { height: 120px; background: #222; padding: 0 10px 10px 10px; display: flex; flex-direction: column; }
        .editor-textarea { flex: 1; background: #111; border: 1px solid #333; color: white; resize: none; padding: 10px; font-family: inherit; outline: none; }
        .editor-textarea:focus { border-color: var(--accent); }

        /* FONT MANAGER MODAL */
        .font-modal-content { width: 400px; background: #222; border: 1px solid #444; padding: 20px; border-radius: 8px; }
        .font-input-group { margin-bottom: 15px; }
        .font-input-group label { display: block; color: #888; margin-bottom: 5px; font-size: 0.9rem; }
        .font-input-group input { width: 100%; padding: 8px; background: #111; border: 1px solid #444; color: white; border-radius: 4px; }
        /* STATUS TEXT */
        #fontStatus { height: 20px; margin-bottom: 10px; font-size: 0.9rem; font-weight: bold; }
        /* INSTALLED FONT LIST */
        .font-list-container {
            max-height: 150px; overflow-y: auto; background: #111; border: 1px solid #444; border-radius: 4px; margin-bottom: 15px;
        }
        .font-list-item {
            padding: 8px 10px; border-bottom: 1px solid #2a2a2a; color: #eee; font-size: 1.1rem; cursor: default;
        }
        .font-list-item:last-child { border-bottom: none; }

        /* SCRIPTURE SETTINGS MODAL */
        .scripture-modal-content {
            width: 800px;
            background: #222;
            border: 1px solid #444;
            padding: 20px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .scripture-preview-container {
            display: flex;
            gap: 20px;
        }
        
        .scripture-controls {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .scripture-preview {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-group label {
            color: #aaa;
            font-size: 0.9rem;
        }
        
        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .control-row input[type="number"] {
            width: 80px;
            padding: 6px;
            background: #111;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
        }
        
        .control-row select {
            flex: 1;
            padding: 6px;
            background: #111;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
        }
        
        .control-row button {
            padding: 6px 12px;
            height: auto;
        }
        
        .size-options {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .size-option {
            padding: 4px 8px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .size-option:hover {
            background: #444;
        }
        
        .size-option.active {
            background: var(--accent);
            border-color: #005f9e;
        }
        
        canvas.scripture-preview-canvas {
            width: 100%;
            aspect-ratio: 16/9;
            background: black;
            border: 1px solid #333;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        /* RANGE ITEM */
        .range-item { background: #0d2b3e; border-left: 3px solid #007acc; color: #fff; font-weight: bold; }
        .range-item:hover { background: #163d55; }

        /* TOAST NOTIFICATION */
        #toast {
            visibility: hidden;
            min-width: 250px;
            margin-left: -125px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 4px;
            padding: 16px;
            position: fixed;
            z-index: 2000;
            left: 50%;
            bottom: 30px;
            font-size: 17px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #555;
        }
        #toast.show {
            visibility: visible;
            -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s;
            animation: fadein 0.5s, fadeout 0.5s 2.5s;
        }
        
        /* Update Banner Style */
        #updateBanner {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #252525;
            border-left: 5px solid #00C4FF;
            color: white;
            padding: 15px 25px;
            border-radius: 4px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            z-index: 3000;
            font-family: 'Segoe UI', sans-serif;
            min-width: 350px;
            text-align: center;
            animation: slideUp 0.5s ease-out;
        }
        #updateBanner h4 { margin: 0 0 5px 0; color: #00C4FF; font-size: 1.1rem; }
        #updateBanner p { margin: 0 0 15px 0; font-size: 0.9rem; color: #ddd; }
        .update-btn {
            background: #007acc;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            text-decoration: none;
            display: inline-block;
        }
        .update-btn:hover { background: #005f9e; }
        .close-update {
            position: absolute;
            top: 5px;
            right: 10px;
            background: none;
            border: none;
            color: #666;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
        }
        .close-update:hover { color: white; }

        /* SAVE PRESENTATION DIALOG */
        .save-dialog {
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            min-width: 400px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        
        .save-dialog h3 {
            margin-top: 0;
            color: #eee;
        }
        
        .save-dialog p {
            color: #ccc;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        @-webkit-keyframes fadein { from {bottom: 0; opacity: 0;} to {bottom: 30px; opacity: 1;} }
        @keyframes fadein { from {bottom: 0; opacity: 0;} to {bottom: 30px; opacity: 1;} }
        @-webkit-keyframes fadeout { from {bottom: 30px; opacity: 1;} to {bottom: 0; opacity: 0;} }
        @keyframes fadeout { from {bottom: 30px; opacity: 1;} to {bottom: 0; opacity: 0;} }
        @keyframes slideUp { from {bottom: -100px; opacity: 0;} to {bottom: 20px; opacity: 1;} }

    </style>
</head>
<body>

    <!-- MENU BAR -->
    <div class="menu-bar" id="menuBar">
        <div class="menu-item" data-menu="file">File
            <div class="dropdown">
                <div onclick="document.getElementById('logoInput').click()">Upload Logo...</div>
                <div class="separator"></div>
                <div onclick="downloadBibleFromWeb()">Fetch Bible (Web)</div>
                <div onclick="downloadHymnsFromWeb()">Fetch Hymns (Web)</div>
                <div onclick="document.getElementById('contentInput').click()">Load Content (Disk)</div>
                <div class="separator"></div>
                <div onclick="saveSchedule()">Save Schedule...</div>
                <div onclick="document.getElementById('scheduleInput').click()">Open Schedule...</div>
                <div class="separator"></div>
                <div onclick="exportPresentations()">Export Presentations...</div>
                <div onclick="document.getElementById('presentationInput').click()">Import Presentations...</div>
                <div class="separator"></div>
                <div onclick="location.reload()">Exit</div>
            </div>
        </div>
        <div class="menu-item">Edit <div class="dropdown"><div>Undo</div><div>Redo</div></div></div>
        <div class="menu-item">Fonts
            <div class="dropdown">
                <div onclick="openFontManager()">Manage Fonts...</div>
            </div>
        </div>
        <div class="menu-item">Window
            <div class="dropdown">
                <div onclick="openProjector()">Open Projector</div>
                <div class="separator"></div>
                <div onclick="openScriptureSettings()">Scripture Display Settings</div>
            </div>
        </div>
        <div style="margin-left:auto; color:#666; font-weight:bold;"><span id="version-display">v2.5.0</span></div>
        <button id="btnFullscreen" onclick="toggleAppFullscreen()" class="btn-toggle-fullscreen" title="Toggle Fullscreen Mode">
             &#x26F6;
        </button>
    </div>

    <!-- HEADER -->
    <header>
        <div class="brand">OpenWorship <span class="brand-badge">CANVAS ENGINE</span></div>
        <div class="controls">
            <button id="btnBlack" onclick="toggleBlack()">Black</button>
            <button id="btnClear" onclick="toggleClear()">Clear</button>
            <button id="btnLogo" onclick="toggleLogo()">Logo</button>
            <div style="width:1px; height:20px; background:#444;"></div>
            <button class="live-btn" onclick="openProjector()">GO LIVE</button>
        </div>
    </header>

    <!-- MAIN BODY -->
    <div class="app-body">
        <div class="top-section">
            <div class="panel panel-left">
                <div class="panel-header">SCHEDULE</div>
                <!-- DROP ZONE SCHEDULE -->
                <div class="schedule-container" id="scheduleList" 
                     ondragover="allowDrop(event)" 
                     ondrop="dropOnSchedule(event)">
                </div>
            </div>
            <div class="panel panel-center" id="slideGrid">
                <div style="color:#444; margin-top:50px;">Select an item to preview</div>
            </div>
            <div class="panel panel-right">
                <div class="panel-header" style="background:none;">LIVE OUTPUT</div>
                <canvas id="monitorCanvas" class="live-monitor" width="1920" height="1080"></canvas>
                <div style="margin-top:5px; color:#666; font-size:0.8rem;">Status: <span id="projStatus">OFFLINE</span></div>
            </div>
        </div>
        <div class="bottom-section">
            <div class="library-tabs">
                <div class="tab active" onclick="switchTab('Song')">Songs</div>
                <div class="tab" onclick="switchTab('Scripture')">Scriptures</div>
                <div class="tab" onclick="switchTab('Presentation')">Presentations</div>
                <div style="flex:1;"></div>
                <input type="text" id="librarySearch" placeholder="Search Library..." style="background:#111; border:1px solid #333; color:white; padding:5px 12px; width:250px; outline:none; border-radius:15px; margin-right:10px;" oninput="handleSearch()">
            </div>
            <div class="library-content">
                <!-- NEW: Separate containers for each tab -->
                <!-- Songs Tab Container -->
                <div class="library-list-container active" id="songListContainer">
                    <div class="library-list" id="libraryListSong"
                         ondragover="allowDrop(event)" 
                         ondrop="dropOnLibrary(event)">
                    </div>
                </div>
                
                <!-- Scriptures Tab Container -->
                <div class="library-list-container" id="scriptureListContainer">
                    <div class="library-list" id="libraryListScripture"
                         ondragover="allowDrop(event)" 
                         ondrop="dropOnLibrary(event)">
                    </div>
                </div>
                
                <!-- Presentations Tab Container -->
                <div class="library-list-container" id="presentationListContainer">
                    <div class="library-list" id="libraryListPresentation"
                         ondragover="allowDrop(event)" 
                         ondrop="dropOnLibrary(event)">
                    </div>
                </div>
                
                <!-- FLOATING ADD BUTTON (Visible on Presentation Tab) -->
                <button class="fab-add" id="addPresBtn" onclick="createNewPresentation()" title="Create New Presentation">+</button>

                <div class="preview-pane-wrapper">
                    <div class="panel-header">PREVIEW</div>
                    <!-- PREVIEW CONTAINER: CONDITIONAL CONTENT -->
                    <div class="library-preview-container">
                        <!-- 1. CANVAS FOR VISUAL PREVIEW (Songs/Presentations) -->
                        <canvas id="libraryPreviewCanvas" class="library-preview-canvas" width="1920" height="1080"></canvas>
                        
                        <!-- 2. TEXT DIV FOR RAW TEXT PREVIEW (Scriptures) -->
                        <div id="libraryPreviewText" style="display: none;">Select an item to preview text...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- DATALIST FOR BIBLE BOOKS -->
    <datalist id="bibleBooks">
        <option value="Genesis"><option value="Exodus"><option value="Leviticus"><option value="Numbers"><option value="Deuteronomy">
        <option value="Joshua"><option value="Judges"><option value="Ruth"><option value="1 Samuel"><option value="2 Samuel">
        <option value="1 Kings"><option value="2 Kings"><option value="1 Chronicles"><option value="2 Chronicles"><option value="Ezra">
        <option value="Nehemiah"><option value="Esther"><option value="Job"><option value="Psalms"><option value="Proverbs">
        <option value="Ecclesiastes"><option value="Song of Solomon"><option value="Isaiah"><option value="Jeremiah"><option value="Lamentations">
        <option value="Ezekiel"><option value="Daniel"><option value="Hosea"><option value="Joel"><option value="Amos">
        <option value="Obadiah"><option value="Jonah"><option value="Micah"><option value="Nahum"><option value="Habakkuk">
        <option value="Zephaniah"><option value="Haggai"><option value="Zechariah"><option value="Malachi">
        <option value="Matthew"><option value="Mark"><option value="Luke"><option value="John"><option value="Acts">
        <option value="Romans"><option value="1 Corinthians"><option value="2 Corinthians"><option value="Galatians"><option value="Ephesians">
        <option value="Philippians"><option value="Colossians"><option value="1 Thessalonians"><option value="2 Thessalonians"><option value="1 Timothy">
        <option value="2 Timothy"><option value="Titus"><option value="Philemon"><option value="Hebrews"><option value="James">
        <option value="1 Peter"><option value="2 Peter"><option value="1 John"><option value="2 John"><option value="3 John">
        <option value="Jude"><option value="Revelation">
    </datalist>

    <!-- TOAST -->
    <div id="toast">Notification</div>
    
    <!-- UPDATE BANNER -->
    <div id="updateBanner">
        <button class="close-update" onclick="document.getElementById('updateBanner').style.display='none'">&times;</button>
        <h4>New Version Available!</h4>
        <p>A newer version of OpenWorship is ready.</p>
        <a href="https://cleo876.github.io/open-worship/" target="_blank" class="update-btn">Download Update</a>
    </div>

    <!-- MODALS & HIDDEN -->
    <div class="modal-overlay" id="editorModal">
        <div class="editor-window">
            <div class="editor-header" style="display:flex; justify-content:space-between; align-items:center;">
                <input type="text" id="editItemTitle" style="padding: 5px; background: #111; color: white; border: 1px solid #444; border-radius: 4px; font-size: 1.1rem; width: 400px; margin-right: 20px;" placeholder="Presentation Title">
                <div><button onclick="closeEditor()">Cancel</button><button class="live-btn" onclick="saveEditorChanges()">Save Changes</button></div>
            </div>
            <div class="editor-body">
                <div class="editor-sidebar"><div style="padding:10px; background:#222; text-align:center;"><button onclick="addNewSlide()" style="width:100%; font-size:0.8rem;">+ Add Slide</button></div><div id="editorSlideList"></div></div>
                <div class="editor-main">
                    <div class="editor-preview-area"><canvas id="editorCanvas" class="editor-canvas" width="1920" height="1080"></canvas></div>
                    <div class="editor-toolbar">
                        <div class="tool-group"><span class="tool-label">Element:</span><button onclick="addTextBlock()">+ Text Block</button></div>
                        <div class="tool-group"><span class="tool-label">Font</span><select id="toolFont" class="tool-input" onchange="updateCurrentBlockStyle()"></select><input type="number" id="toolSize" class="tool-input" style="width:60px;" value="90" onchange="updateCurrentBlockStyle()" list="sizePresets"><datalist id="sizePresets"><option value="40"></option><option value="60"></option><option value="90"></option><option value="120"></option><option value="150"></option><option value="200"></option></datalist></div>
                        <div class="tool-group"><button class="tool-btn" onclick="toggleStyle('bold')" style="font-weight:bold;">B</button><button class="tool-btn" onclick="toggleStyle('italic')" style="font-style:italic;">I</button><input type="color" id="toolColor" class="tool-input" style="width:40px; height:28px; padding:0;" onchange="updateCurrentBlockStyle()"></div>
                        <div class="tool-group"><button onclick="document.getElementById('bgUpload').click()">BG Image</button><input type="file" id="bgUpload" style="display:none;" accept="image/*" onchange="uploadSlideBG(this)"><button onclick="clearSlideBG()">No BG</button></div>
                        <button onclick="removeCurrentBlock()" style="color:#d32f2f; margin-left:auto;">Delete Block</button>
                    </div>
                    <div class="editor-text-input"><textarea id="editorTextArea" class="editor-textarea" placeholder="Select a text block to edit..." oninput="updateCurrentBlockText()"></textarea></div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="fontManager">
        <div class="font-modal-content">
            <h3 style="margin-top:0; color:#eee;">Manage Fonts</h3>
            <div id="fontStatus"></div>
            <div class="font-input-group"><label>Add from Google Fonts</label><div style="display:flex; gap:5px;"><input type="text" id="googleFontName" placeholder="Font Name"><button onclick="fetchGoogleFont()">Fetch</button></div><a href="https://fonts.google.com" target="_blank" style="font-size:0.8rem; color:#007acc; text-decoration:none; display:block; margin-top:5px;">Browse Google Fonts</a></div>
            <div class="separator"></div>
            <div class="font-input-group"><label>Upload Local Font</label><div style="display:flex; gap:5px;"><button onclick="document.getElementById('localFontInput').click()" style="width:100%;">Select File</button><input type="file" id="localFontInput" accept=".ttf,.otf" style="display:none" onchange="uploadLocalFont(this)"></div></div>
            <div class="separator"></div>
            <label style="display:block; color:#888; margin-bottom:5px; font-size:0.9rem;">Installed Fonts</label>
            <div id="installedFontsList" class="font-list-container"></div>
            <div style="text-align:right; margin-top:20px;"><button onclick="document.getElementById('fontManager').style.display='none'">Close</button></div>
        </div>
    </div>

    <!-- SCRIPTURE SETTINGS MODAL -->
    <div class="modal-overlay" id="scriptureSettingsModal">
        <div class="scripture-modal-content">
            <h3 style="margin-top:0; color:#eee;">Scripture Display Settings</h3>
            <div class="scripture-preview-container">
                <div class="scripture-controls">
                    <div class="control-group">
                        <label>Scripture Text Font</label>
                        <div class="control-row">
                            <select id="scriptureFontSelect"></select>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Scripture Text Size</label>
                        <div class="control-row">
                            <input type="number" id="scriptureSizeInput" min="20" max="200" value="90">
                            <button onclick="addScriptureSize()">Add Size</button>
                        </div>
                        <div class="size-options" id="scriptureSizeOptions"></div>
                    </div>
                    
                    <div class="control-group">
                        <label>Reference Footer Size</label>
                        <div class="control-row">
                            <input type="number" id="footerSizeInput" min="20" max="100" value="40">
                            <button onclick="addFooterSize()">Add Size</button>
                        </div>
                        <div class="size-options" id="footerSizeOptions"></div>
                    </div>
                    
                    <div class="control-group">
                        <label>Test Scripture</label>
                        <div class="control-row">
                            <select id="testScriptureSelect">
                                <option value="John 3:16">John 3:16 - For God so loved...</option>
                                <option value="Psalm 23:1">Psalm 23:1 - The Lord is my shepherd...</option>
                                <option value="Matthew 28:19">Matthew 28:19 - Go therefore and make disciples...</option>
                                <option value="Romans 8:28">Romans 8:28 - And we know that all things...</option>
                            </select>
                            <button onclick="updateScripturePreview()">Update Preview</button>
                        </div>
                    </div>
                </div>
                
                <div class="scripture-preview">
                    <canvas id="scripturePreviewCanvas" class="scripture-preview-canvas" width="1920" height="1080"></canvas>
                </div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
                <button onclick="resetScriptureSettings()">Reset to Default</button>
                <button onclick="document.getElementById('scriptureSettingsModal').style.display='none'">Cancel</button>
                <button class="live-btn" onclick="saveScriptureSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- SAVE ALERT MODAL -->
    <div class="modal-overlay" id="saveAlertModal">
        <div class="modal">
            <h3>Content Fetched!</h3>
            <p id="saveMsg" style="color:#ccc; font-size:0.9rem; line-height:1.5;"></p>
            <div class="modal-buttons"><button onclick="document.getElementById('saveAlertModal').style.display='none'">Close</button><button class="live-btn" id="btnSaveDisk">Save File</button></div>
        </div>
    </div>

    <!-- SAVE PRESENTATION DIALOG -->
    <div class="modal-overlay" id="savePresentationDialog">
        <div class="save-dialog">
            <h3>Save Presentations?</h3>
            <p>You have created or modified presentations. Would you like to save them to your computer before exiting?</p>
            <p style="color: #ff9800; font-size: 0.9rem;"><strong>Note:</strong> Presentations are automatically saved in your browser's storage, but exporting to a file ensures you can restore them on any computer.</p>
            <div class="dialog-buttons">
                <button onclick="document.getElementById('savePresentationDialog').style.display='none'">Don't Save</button>
                <button onclick="exportPresentations()" class="live-btn">Save Presentations</button>
                <button onclick="savePresentationsToStorage(); document.getElementById('savePresentationDialog').style.display='none'">Just Save to Browser</button>
            </div>
        </div>
    </div>

    <input type="file" id="logoInput" style="display:none" accept="image/*" onchange="handleLogoUpload(this)">
    <input type="file" id="contentInput" accept=".json,.bible,.hymn" style="display:none" onchange="handleContentLoad(this)">
    <input type="file" id="scheduleInput" style="display:none" accept=".schedule,.json" onchange="handleScheduleLoad(this)">
    <input type="file" id="presentationInput" style="display:none" accept=".json" onchange="handlePresentationLoad(this)">
    
    <div id="contextMenu" class="dropdown" style="position:absolute;">
        <div id="ctxEdit">Edit Item</div>
        <div id="ctxRename">Rename Item</div>
        <div id="ctxRemove">Remove</div>
    </div>

    <script>
        // REMINDER: Use 3-digit semantic versioning (Major.Minor.Patch) for this project (e.g., v2.5.0).
        // GLOBAL DATA
        const RESOLUTION = { width: 1920, height: 1080 };
        const STORAGE_KEY = 'openworship_presentations_v2';
        const SCRIPTURE_SETTINGS_KEY = 'openworship_scripture_settings';
        const FONT_SIZES_KEY = 'openworship_font_sizes';
        
        let library = [
            { id: 1, title: "Way Maker", type: "Song", slides: [ {layers:[{text:"You are here\nMoving in our midst", style:{fontSize:90}}]}, {layers:[{text:"Way maker, miracle worker", style:{fontSize:90}}]} ] },
            { id: 2, title: "10,000 Reasons", type: "Song", slides: [ {layers:[{text:"Bless the Lord O my soul", style:{fontSize:90}}]} ] }
        ];
        let bibleLibrary = []; 
        
        let schedule = JSON.parse(JSON.stringify(library)); 
        let currentTab = 'Song';
        let projectorWindow = null, logoImage = null;
        let isBlack = false, isClear = false, isLogo = false;
        let editingItem = null, tempSlides = [], currentSlideIndex = 0, selectedLayerIndex = 0; 
        let availableFonts = ["Segoe UI", "Arial", "Times New Roman", "Courier New", "Poppins", "Oswald", "Open Sans"];
        let downloadedBibleData = null;

        // GLOBAL DRAG STATE
        let dragSource = null; 
        let dragIndex = -1;
        let dragItem = null; 

        // GLOBAL NAV STATE
        let currentGridSlides = [];
        let currentSlideIdx = -1;
        let liveState = { slide: null, item: null }; 

        // SCRIPTURE SCROLLING STATE - Now separate for each tab
        let visibleScriptureCount = { Song: 500, Scripture: 500, Presentation: 500 };
        let rightClickedItem = null;
        let isScriptureRendering = false;
        let currentTabScrollPositions = { Song: 0, Scripture: 0, Presentation: 0 };

        // PRESENTATION PERSISTENCE STATE
        let presentationsModified = false;

        // FONT SYNCHRONIZATION FOR PROJECTOR
        let localFontData = {}; // Store local font data URLs for projector synchronization

        // SCRIPTURE DISPLAY SETTINGS
        let scriptureSettings = {
            font: "Segoe UI",
            scriptureSize: 90,
            footerSize: 40,
            bold: false,
            italic: false,
            color: "#ffffff"
        };

        // FONT SIZE MEMORY
        let customFontSizes = {
            scriptureSizes: [40, 60, 90, 120, 150, 200],
            footerSizes: [30, 40, 50, 60],
            editorSizes: [40, 60, 90, 120, 150, 200]
        };

        // HELPER FUNCTION: Convert ArrayBuffer to Base64
        function arrayBufferToBase64(buffer) {
            let binary = '';
            let bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // INIT
        function init() {
            // Load saved presentations from localStorage
            loadPresentationsFromStorage();
            
            // Load scripture settings
            loadScriptureSettings();
            
            // Load custom font sizes
            loadCustomFontSizes();
            
            renderSchedule();
            switchTab('Song');
            renderSlide(document.getElementById('monitorCanvas').getContext('2d'), null);
            renderSlide(document.getElementById('libraryPreviewCanvas').getContext('2d'), {layers:[{text:"Select Item", style:{fontSize:60}}]});

            document.querySelectorAll('.menu-item').forEach(m => {
                m.addEventListener('click', e => { e.stopPropagation(); document.querySelectorAll('.menu-item').forEach(i => i !== m && i.classList.remove('active')); m.classList.toggle('active'); });
                m.addEventListener('mouseenter', () => { if(document.querySelector('.menu-item.active')) { document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active')); m.classList.add('active'); }});
            });
            document.addEventListener('click', () => { document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active')); document.getElementById('contextMenu').style.display = 'none'; });
            
            // Bind Search
            document.getElementById('librarySearch').setAttribute('list', 'bibleBooks');
            
            // Ensure scroll events are properly bound for each list
            document.getElementById('libraryListSong').addEventListener('scroll', handleLibraryScroll);
            document.getElementById('libraryListScripture').addEventListener('scroll', handleLibraryScroll);
            document.getElementById('libraryListPresentation').addEventListener('scroll', handleLibraryScroll);

            setupEditorInteraction();
            setupKeyboardNav();
            
            // Initialize version display
            document.getElementById('version-display').textContent = 'v' + TOOL_VERSION;

            // Start version check
            checkForUpdates();
            
            // Add beforeunload event to prompt for saving presentations
            window.addEventListener('beforeunload', (e) => {
                if (presentationsModified) {
                    // Check if there are any presentations
                    const presentations = library.filter(item => item.type === 'Presentation');
                    if (presentations.length > 0) {
                        e.preventDefault();
                        e.returnValue = 'You have unsaved presentations. Would you like to save them before leaving?';
                        showSavePresentationDialog();
                        return e.returnValue;
                    }
                }
            });
        }
        
        // --- SCRIPTURE SETTINGS FUNCTIONS ---
        function loadScriptureSettings() {
            try {
                const saved = localStorage.getItem(SCRIPTURE_SETTINGS_KEY);
                if (saved) {
                    const settings = JSON.parse(saved);
                    scriptureSettings = { ...scriptureSettings, ...settings };
                }
            } catch (error) {
                console.error('Error loading scripture settings:', error);
            }
        }
        
        function saveScriptureSettings() {
            try {
                localStorage.setItem(SCRIPTURE_SETTINGS_KEY, JSON.stringify(scriptureSettings));
                showToast('Scripture display settings saved!');
                document.getElementById('scriptureSettingsModal').style.display = 'none';
                
                // Update any live scripture display
                if (liveState.item && liveState.item.type === 'Scripture') {
                    reRenderLive();
                }
            } catch (error) {
                console.error('Error saving scripture settings:', error);
                showToast('Error saving scripture settings');
            }
        }
        
        function openScriptureSettings() {
            const modal = document.getElementById('scriptureSettingsModal');
            modal.style.display = 'flex';
            
            // Populate font select
            const fontSelect = document.getElementById('scriptureFontSelect');
            fontSelect.innerHTML = '';
            availableFonts.forEach(font => {
                const option = document.createElement('option');
                option.value = font;
                option.textContent = font;
                if (font === scriptureSettings.font) option.selected = true;
                fontSelect.appendChild(option);
            });
            
            // Set current values
            document.getElementById('scriptureSizeInput').value = scriptureSettings.scriptureSize;
            document.getElementById('footerSizeInput').value = scriptureSettings.footerSize;
            
            // Populate size options
            updateSizeOptions();
            
            // Update preview
            updateScripturePreview();
            
            // Add event listeners for real-time preview
            fontSelect.addEventListener('change', updateScripturePreview);
            document.getElementById('scriptureSizeInput').addEventListener('input', updateScripturePreview);
            document.getElementById('footerSizeInput').addEventListener('input', updateScripturePreview);
            document.getElementById('testScriptureSelect').addEventListener('change', updateScripturePreview);
        }
        
        function updateSizeOptions() {
            // Update scripture size options
            const scriptureSizeOptions = document.getElementById('scriptureSizeOptions');
            scriptureSizeOptions.innerHTML = '';
            customFontSizes.scriptureSizes.forEach(size => {
                const div = document.createElement('div');
                div.className = `size-option ${size === scriptureSettings.scriptureSize ? 'active' : ''}`;
                div.textContent = size;
                div.onclick = () => {
                    scriptureSettings.scriptureSize = size;
                    document.getElementById('scriptureSizeInput').value = size;
                    updateScripturePreview();
                    updateSizeOptions();
                };
                scriptureSizeOptions.appendChild(div);
            });
            
            // Update footer size options
            const footerSizeOptions = document.getElementById('footerSizeOptions');
            footerSizeOptions.innerHTML = '';
            customFontSizes.footerSizes.forEach(size => {
                const div = document.createElement('div');
                div.className = `size-option ${size === scriptureSettings.footerSize ? 'active' : ''}`;
                div.textContent = size;
                div.onclick = () => {
                    scriptureSettings.footerSize = size;
                    document.getElementById('footerSizeInput').value = size;
                    updateScripturePreview();
                    updateSizeOptions();
                };
                footerSizeOptions.appendChild(div);
            });
        }
        
        function addScriptureSize() {
            const input = document.getElementById('scriptureSizeInput');
            const size = parseInt(input.value);
            if (size && size >= 20 && size <= 200) {
                if (!customFontSizes.scriptureSizes.includes(size)) {
                    customFontSizes.scriptureSizes.push(size);
                    customFontSizes.scriptureSizes.sort((a, b) => a - b);
                    saveCustomFontSizes();
                    updateSizeOptions();
                }
                scriptureSettings.scriptureSize = size;
                updateScripturePreview();
            }
        }
        
        function addFooterSize() {
            const input = document.getElementById('footerSizeInput');
            const size = parseInt(input.value);
            if (size && size >= 20 && size <= 100) {
                if (!customFontSizes.footerSizes.includes(size)) {
                    customFontSizes.footerSizes.push(size);
                    customFontSizes.footerSizes.sort((a, b) => a - b);
                    saveCustomFontSizes();
                    updateSizeOptions();
                }
                scriptureSettings.footerSize = size;
                updateScripturePreview();
            }
        }
        
        function updateScripturePreview() {
            // Update settings from inputs
            scriptureSettings.font = document.getElementById('scriptureFontSelect').value;
            scriptureSettings.scriptureSize = parseInt(document.getElementById('scriptureSizeInput').value);
            scriptureSettings.footerSize = parseInt(document.getElementById('footerSizeInput').value);
            
            // Get test scripture text
            const testScripture = document.getElementById('testScriptureSelect').value;
            let scriptureText = "";
            let reference = "";
            
            switch(testScripture) {
                case "John 3:16":
                    scriptureText = "For God so loved the world that he gave his one and only Son, that whoever believes in him shall not perish but have eternal life.";
                    reference = "John 3:16";
                    break;
                case "Psalm 23:1":
                    scriptureText = "The Lord is my shepherd, I lack nothing. He makes me lie down in green pastures, he leads me beside quiet waters.";
                    reference = "Psalm 23:1";
                    break;
                case "Matthew 28:19":
                    scriptureText = "Go therefore and make disciples of all nations, baptizing them in the name of the Father and of the Son and of the Holy Spirit.";
                    reference = "Matthew 28:19";
                    break;
                case "Romans 8:28":
                    scriptureText = "And we know that in all things God works for the good of those who love him, who have been called according to his purpose.";
                    reference = "Romans 8:28";
                    break;
            }
            
            // Render preview
            const canvas = document.getElementById('scripturePreviewCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, RESOLUTION.width, RESOLUTION.height);
            
            // Render scripture text with current settings
            const fontSize = scriptureSettings.scriptureSize;
            const fontFace = scriptureSettings.font;
            const color = scriptureSettings.color;
            
            ctx.font = `${scriptureSettings.italic ? 'italic' : ''} ${scriptureSettings.bold ? 'bold' : ''} ${fontSize}px "${fontFace}"`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = color;
            
            // Word wrap
            const maxWidth = RESOLUTION.width - 200;
            const words = scriptureText.split(' ');
            let lines = [];
            let currentLine = words[0];
            
            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' ' + words[i];
                const metrics = ctx.measureText(testLine);
                if (metrics.width < maxWidth) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    currentLine = words[i];
                }
            }
            lines.push(currentLine);
            
            // Calculate positioning
            const lineHeight = fontSize * 1.2;
            const totalHeight = lines.length * lineHeight;
            const startY = (RESOLUTION.height - totalHeight) / 2 + (lineHeight / 2);
            
            // Draw text with shadow
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight);
                ctx.fillText(line, RESOLUTION.width / 2, y);
            });
            
            // Draw reference footer
            ctx.shadowBlur = 0;
            ctx.font = `bold ${scriptureSettings.footerSize}px Arial`;
            ctx.textAlign = 'right';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText(`- ${reference} (KJV)`, RESOLUTION.width - 50, RESOLUTION.height - 50);
            
            // Update size options highlight
            updateSizeOptions();
        }
        
        function resetScriptureSettings() {
            scriptureSettings = {
                font: "Segoe UI",
                scriptureSize: 90,
                footerSize: 40,
                bold: false,
                italic: false,
                color: "#ffffff"
            };
            
            document.getElementById('scriptureFontSelect').value = scriptureSettings.font;
            document.getElementById('scriptureSizeInput').value = scriptureSettings.scriptureSize;
            document.getElementById('footerSizeInput').value = scriptureSettings.footerSize;
            
            updateScripturePreview();
            showToast('Scripture settings reset to default');
        }
        
        // --- CUSTOM FONT SIZE FUNCTIONS ---
        function loadCustomFontSizes() {
            try {
                const saved = localStorage.getItem(FONT_SIZES_KEY);
                if (saved) {
                    const sizes = JSON.parse(saved);
                    customFontSizes = { ...customFontSizes, ...sizes };
                    
                    // Update editor datalist
                    updateEditorSizeDatalist();
                }
            } catch (error) {
                console.error('Error loading font sizes:', error);
            }
        }
        
        function saveCustomFontSizes() {
            try {
                localStorage.setItem(FONT_SIZES_KEY, JSON.stringify(customFontSizes));
                updateEditorSizeDatalist();
            } catch (error) {
                console.error('Error saving font sizes:', error);
            }
        }
        
        function updateEditorSizeDatalist() {
            const datalist = document.getElementById('sizePresets');
            datalist.innerHTML = '';
            
            // Add default sizes
            [40, 60, 90, 120, 150, 200].forEach(size => {
                if (!customFontSizes.editorSizes.includes(size)) {
                    customFontSizes.editorSizes.push(size);
                }
            });
            
            // Sort and add to datalist
            customFontSizes.editorSizes.sort((a, b) => a - b);
            customFontSizes.editorSizes.forEach(size => {
                const option = document.createElement('option');
                option.value = size;
                datalist.appendChild(option);
            });
        }
        
        function addEditorSize(size) {
            if (size && !customFontSizes.editorSizes.includes(size)) {
                customFontSizes.editorSizes.push(size);
                customFontSizes.editorSizes.sort((a, b) => a - b);
                saveCustomFontSizes();
            }
        }
        
        // --- PRESENTATION STORAGE FUNCTIONS ---
        function loadPresentationsFromStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const savedPresentations = JSON.parse(saved);
                    if (Array.isArray(savedPresentations)) {
                        // Remove existing presentations from library
                        library = library.filter(item => item.type !== 'Presentation');
                        
                        // Add saved presentations
                        savedPresentations.forEach(presentation => {
                            // Ensure each presentation has a unique ID
                            if (!presentation.id) presentation.id = Date.now() + Math.random();
                            library.push(presentation);
                        });
                        
                        console.log(`Loaded ${savedPresentations.length} presentations from storage`);
                    }
                }
            } catch (error) {
                console.error('Error loading presentations from storage:', error);
            }
        }
        
        function savePresentationsToStorage() {
            try {
                const presentations = library.filter(item => item.type === 'Presentation');
                localStorage.setItem(STORAGE_KEY, JSON.stringify(presentations));
                presentationsModified = false;
                console.log(`Saved ${presentations.length} presentations to storage`);
            } catch (error) {
                console.error('Error saving presentations to storage:', error);
                showToast('Error saving presentations to browser storage');
            }
        }
        
        function markPresentationsModified() {
            presentationsModified = true;
        }
        
        function showSavePresentationDialog() {
            const presentations = library.filter(item => item.type === 'Presentation');
            if (presentations.length > 0) {
                document.getElementById('savePresentationDialog').style.display = 'flex';
            }
        }
        
        function exportPresentations() {
            const presentations = library.filter(item => item.type === 'Presentation');
            if (presentations.length === 0) {
                showToast("No presentations to export!");
                return;
            }
            
            document.body.style.cursor = 'wait';
            
            // Create export data with metadata
            const exportData = {
                version: TOOL_VERSION,
                exportDate: new Date().toISOString(),
                type: 'OpenWorship Presentations',
                presentations: presentations
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `OpenWorship_Presentations_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            document.body.style.cursor = 'default';
            showToast(`Exported ${presentations.length} presentations!`);
            document.getElementById('savePresentationDialog').style.display = 'none';
            savePresentationsToStorage(); // Also save to localStorage
        }
        
        function handlePresentationLoad(input) {
            if (input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        let presentations = [];
                        
                        // Handle different file formats
                        if (data.presentations && Array.isArray(data.presentations)) {
                            // New format with metadata
                            presentations = data.presentations;
                        } else if (Array.isArray(data)) {
                            // Old format - just array of presentations
                            presentations = data.filter(item => item.type === 'Presentation');
                        } else {
                            showToast("Invalid presentation file format");
                            return;
                        }
                        
                        if (presentations.length === 0) {
                            showToast("No presentations found in file");
                            return;
                        }
                        
                        // Remove existing presentations
                        library = library.filter(item => item.type !== 'Presentation');
                        
                        // Add imported presentations with new IDs to avoid conflicts
                        presentations.forEach(pres => {
                            const newPres = JSON.parse(JSON.stringify(pres));
                            newPres.id = Date.now() + Math.random();
                            library.push(newPres);
                        });
                        
                        // Save to localStorage
                        savePresentationsToStorage();
                        
                        // Refresh the library view
                        if (currentTab === 'Presentation') {
                            renderLibrary();
                        }
                        
                        showToast(`Imported ${presentations.length} presentations!`);
                        input.value = '';
                        
                    } catch (err) {
                        showToast("Error reading presentation file: " + err.message);
                    }
                };
                
                reader.readAsText(file);
            }
        }
        
        // --- VERSION CHECK ---
        async function checkForUpdates() {
            setTimeout(async () => {
                try {
                    const response = await fetch(GITHUB_SOURCE_URL);
                    if (!response.ok) return;
                    
                    const text = await response.text();
                    const match = text.match(/const\s+TOOL_VERSION\s+=\s+['"]([\d\.]+)['"];/);
                    
                    if (match && match[1]) {
                        const onlineVersion = match[1];
                        if (compareVersions(onlineVersion, TOOL_VERSION) > 0) {
                            const banner = document.getElementById('updateBanner');
                            banner.style.display = 'block';
                        }
                    }
                } catch (e) {
                    console.log("Update check skipped (offline or error).");
                }
            }, 3000);
        }

        function compareVersions(v1, v2) {
            const parts1 = v1.split('.').map(Number);
            const parts2 = v2.split('.').map(Number);
            for (let i = 0; i < 3; i++) {
                if (parts1[i] > parts2[i]) return 1;
                if (parts1[i] < parts2[i]) return -1;
            }
            return 0;
        }
        
        // --- FULLSCREEN TOGGLE (KARAT MODE) ---
        function toggleAppFullscreen() {
            const body = document.documentElement;
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else if (body.requestFullscreen) {
                body.requestFullscreen();
            } else if (body.webkitRequestFullscreen) {
                body.webkitRequestFullscreen();
            } else if (body.msRequestFullscreen) {
                body.msRequestFullscreen();
            }
        }
        
        // --- FULLSCREEN BUTTON STYLE UPDATE ---
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('btnFullscreen');
            if (btn) {
                if (document.fullscreenElement) {
                    btn.classList.add('active-state');
                } else {
                    btn.classList.remove('active-state');
                }
            }
        });

        // --- TOAST NOTIFICATION ---
        function showToast(message) {
            const x = document.getElementById("toast");
            x.innerText = message;
            x.className = "show";
            setTimeout(function(){ x.className = x.className.replace("show", ""); }, 3000);
        }

        // --- CENTRALIZED TRANSITION LOGIC (SYMMETRIC FADE) ---
        function transitionLiveState(newSlide, newItem, footer) {
            const monitor = document.getElementById('monitorCanvas');
            let pCanvas = null;
            if(projectorWindow && !projectorWindow.closed) {
                pCanvas = projectorWindow.document.getElementById('projectorCanvas');
            }

            monitor.classList.add('fading');
            if(pCanvas) pCanvas.classList.add('fading');

            setTimeout(() => {
                // Apply scripture settings if this is a scripture
                if (newItem && newItem.type === 'Scripture' && newSlide) {
                    const settings = scriptureSettings;
                    if (newSlide.layers && newSlide.layers.length > 0) {
                        newSlide.layers[0].style = {
                            ...newSlide.layers[0].style,
                            font: settings.font,
                            fontSize: settings.scriptureSize,
                            color: settings.color,
                            bold: settings.bold,
                            italic: settings.italic
                        };
                    }
                }
                
                renderSlide(monitor.getContext('2d'), newSlide, footer);
                if(pCanvas) {
                    renderSlide(pCanvas.getContext('2d'), newSlide, footer);
                    pCanvas.classList.remove('fading');
                }
                monitor.classList.remove('fading');
                
                liveState.slide = newSlide;
                liveState.item = newItem;
            }, 300);
        }

        // --- GO LIVE ---
        function goLive(slide, item, el) {
            document.querySelectorAll('.slide-wrapper').forEach(x => x.classList.remove('active')); 
            if(el) el.classList.add('active');
            
            let footer = "";
            if (slide && slide.verseReference) {
                footer = `- ${slide.verseReference} (KJV)`;
            } else if (item && item.type === 'Scripture') {
                footer = `- ${item.title} (KJV)`;
            }

            transitionLiveState(slide, item, footer);
        }

        // --- TOGGLES (FIXED TO USE TRANSITION) ---
        function reRenderLive() { 
            let active = document.querySelector('.slide-wrapper.active'); 
            if(active) {
                active.click(); 
            } else {
                let footer = "";
                if (liveState.slide && liveState.slide.verseReference) footer = `- ${liveState.slide.verseReference} (KJV)`;
                else if (liveState.item && liveState.item.type === 'Scripture') footer = `- ${liveState.item.title} (KJV)`;
                transitionLiveState(liveState.slide, liveState.item, footer);
            }
        }

        function toggleBlack() { isBlack=!isBlack; document.getElementById('btnBlack').classList.toggle('active-state'); reRenderLive(); }
        function toggleClear() { isClear=!isClear; document.getElementById('btnClear').classList.toggle('active-state'); reRenderLive(); }
        
        function toggleLogo() { 
            isLogo = !isLogo; 
            document.getElementById('btnLogo').classList.toggle('active-state'); 
            reRenderLive(); 
        }

        // --- LOGO UPLOAD ---
        function handleLogoUpload(input) { 
            if(input.files[0]) { 
                let r = new FileReader(); 
                r.onload = e => { 
                    logoImage=new Image(); 
                    logoImage.src=e.target.result; 
                    showToast("Logo Set Successfully"); 
                    if(isLogo) reRenderLive(); 
                }; 
                r.readAsDataURL(input.files[0]); 
            }
        }

        // --- OPEN PROJECTOR (UPDATED FOR 1:1 FONT SYNCHRONIZATION) ---
        function openProjector() {
            if(projectorWindow && !projectorWindow.closed) {
                projectorWindow.focus();
            } else {
                // Collect all installed fonts and their data URLs
                let fontStyles = '';
                for (let fontName in localFontData) {
                    fontStyles += `@font-face { font-family: "${fontName}"; src: url(${localFontData[fontName]}); }\n`;
                }
                
                // Also include Google Fonts
                const googleFontsLink = 'https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&family=Oswald:wght@400;700&family=Poppins:wght@400;700&display=swap';
                
                projectorWindow = window.open("", "Projector", "width=800,height=600");
                projectorWindow.document.write(`
                    <html>
                    <head>
                        <title>LIVE OUTPUT</title>
                        <link href="${googleFontsLink}" rel="stylesheet">
                        <style>
                            body { margin:0; background:black; overflow:hidden; }
                            canvas { width:100vw; height:100vh; object-fit:contain; display:block; transition: opacity 0.3s ease; }
                            .fading { opacity: 0; }
                            ${fontStyles}
                        </style>
                    </head>
                    <body>
                        <canvas id="projectorCanvas" width="${RESOLUTION.width}" height="${RESOLUTION.height}"></canvas>
                    </body>
                    <script>
                        // Font synchronization function
                        function synchronizeFonts() {
                            try {
                                // Request font data from parent window
                                if (window.opener && !window.opener.closed) {
                                    // Get available fonts from parent
                                    const availableFonts = window.opener.availableFonts || [];
                                    const localFontData = window.opener.localFontData || {};
                                    
                                    // Create font faces for local fonts
                                    for (let fontName in localFontData) {
                                        try {
                                            const fontFace = new FontFace(fontName, \`url(\${localFontData[fontName]})\`);
                                            document.fonts.add(fontFace);
                                        } catch(e) {
                                            console.log("Failed to load font:", fontName);
                                        }
                                    }
                                }
                            } catch(e) {
                                console.log("Font sync error:", e);
                            }
                        }
                        
                        // Sync fonts on load
                        window.addEventListener('load', synchronizeFonts);
                        
                        document.addEventListener('dblclick', () => { 
                            if(!document.fullscreenElement) document.documentElement.requestFullscreen(); 
                            else document.exitFullscreen(); 
                        });
                        document.addEventListener('click', (e) => e.preventDefault());
                    <\/script>
                    </html>
                `);
                
                // Wait for window to load, then render
                projectorWindow.onload = () => { 
                    document.getElementById('projStatus').innerText = "LIVE"; 
                    document.getElementById('projStatus').style.color = "#4caf50"; 
                    
                    // Force re-render to ensure projector gets exact same output
                    setTimeout(() => {
                        reRenderLive();
                        
                        // Additional font sync check
                        if (projectorWindow) {
                            try {
                                projectorWindow.synchronizeFonts && projectorWindow.synchronizeFonts();
                            } catch(e) {
                                console.log("Projector font sync:", e);
                            }
                        }
                    }, 500);
                };
                
                const timer = setInterval(() => {
                    if (projectorWindow.closed) {
                        clearInterval(timer);
                        const status = document.getElementById('projStatus');
                        if(status) { status.innerText = "OFFLINE"; status.style.color = "#d32f2f"; }
                    }
                }, 1000);
            }
        }

        // --- KEYBOARD NAVIGATION ---
        function setupKeyboardNav() {
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (currentGridSlides.length > 0) {
                    if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        if (currentSlideIdx < currentGridSlides.length - 1) {
                            const wrappers = document.querySelectorAll('#slideGrid .slide-wrapper');
                            let nextIdx = currentSlideIdx + 1;
                            if (wrappers[nextIdx]) wrappers[nextIdx].click();
                        }
                    } else if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        if (currentSlideIdx > 0) {
                            const wrappers = document.querySelectorAll('#slideGrid .slide-wrapper');
                            let prevIdx = currentSlideIdx - 1;
                            if (wrappers[prevIdx]) wrappers[prevIdx].click();
                        }
                    }
                }
            });
        }

        // --- SCROLL LOGIC (now tab-specific) ---
        function handleLibraryScroll(e) {
            const container = e.target;
            const containerId = container.id;
            
            // Save scroll position for current tab
            if (containerId === 'libraryListSong') {
                currentTabScrollPositions.Song = container.scrollTop;
            } else if (containerId === 'libraryListScripture') {
                currentTabScrollPositions.Scripture = container.scrollTop;
                handleScriptureScroll(container);
            } else if (containerId === 'libraryListPresentation') {
                currentTabScrollPositions.Presentation = container.scrollTop;
            }
        }
        
        function handleScriptureScroll(container) {
            if (currentTab !== 'Scripture') return;
            if (isScriptureRendering) return;
            
            const scrollThreshold = 100;
            const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight <= scrollThreshold;
            
            if (isNearBottom) {
                const query = document.getElementById('librarySearch').value;
                const lowerQ = query.toLowerCase();
                const filtered = bibleLibrary.filter(item => item.title.toLowerCase().includes(lowerQ));
                
                if (visibleScriptureCount.Scripture < filtered.length) {
                    isScriptureRendering = true;
                    visibleScriptureCount.Scripture += 500;
                    
                    setTimeout(() => {
                        renderScriptureList(query, true);
                        isScriptureRendering = false;
                    }, 50);
                }
            }
        }

        // --- SEARCH LOGIC ---
        function handleSearch() {
            const query = document.getElementById('librarySearch').value;
            
            // Reset scroll count for new searches (except when typing ranges)
            const rangeRegex = /^([1-3]?\s?[a-zA-Z]+)\s+(\d+):(\d+)-(\d+)$/;
            const match = query.match(rangeRegex);
            
            if (!match) {
                visibleScriptureCount.Scripture = 500;
            }
            
            if (currentTab === 'Scripture') {
                renderScriptureList(query, false);
            } else if (currentTab === 'Song') {
                visibleScriptureCount.Song = 500;
                renderLibrary(false);
            } else if (currentTab === 'Presentation') {
                visibleScriptureCount.Presentation = 500;
                renderLibrary(false);
            }
        }

        function renderScriptureList(query, append = false) {
            let container = document.getElementById('libraryListScripture');
            
            // Switch Preview Mode
            document.getElementById('libraryPreviewCanvas').style.display = 'none';
            document.getElementById('libraryPreviewText').style.display = 'block';
            
            if (!append) {
                container.innerHTML = "";
                visibleScriptureCount.Scripture = 500;
            }
            
            const rangeRegex = /^([1-3]?\s?[a-zA-Z]+)\s+(\d+):(\d+)-(\d+)$/;
            const match = query.match(rangeRegex);

            // --- 1. HANDLE RANGE ITEM ---
            if (match) {
                const book = match[1];
                const chapter = parseInt(match[2]);
                const startV = parseInt(match[3]);
                const endV = parseInt(match[4]);
                
                const verses = bibleLibrary.filter(v => v.title.startsWith(`${book} ${chapter}:`)).filter(v => {
                    const vNum = parseInt(v.title.split(':')[1]);
                    return vNum >= startV && vNum <= endV;
                });

                if (verses.length > 0) {
                    let compositeItem = {
                        id: Date.now(),
                        title: `${book} ${chapter}:${startV}-${endV} (Range)`,
                        type: 'Scripture',
                        slides: verses.map(v => {
                            let s = JSON.parse(JSON.stringify(v.slides[0]));
                            s.verseReference = v.title; 
                            return s;
                        })
                    };

                    let div = document.createElement('div');
                    div.className = 'schedule-item range-item';
                    div.innerHTML = `<span>${compositeItem.title}</span>`;
                    div.draggable = true;
                    div.ondragstart = (e) => startDrag(e, 'library', -1, compositeItem);
                    
                    div.onclick = () => {
                         const content = compositeItem.slides.map(s => `${s.verseReference}\n${s.layers[0].text}`).join('\n\n---\n\n');
                         document.getElementById('libraryPreviewText').innerText = content;
                    };
                    div.ondblclick = () => goLive(compositeItem.slides[0], compositeItem);
                    container.appendChild(div);
                    
                    // If we found a range, we should clear any regular search results
                    // But only if not appending (new search)
                    if (!append) {
                        // Don't show regular results when we have a range
                        return;
                    }
                }
            }

            // --- 2. HANDLE SCROLLABLE LIST (only if no range was found or we're appending) ---
            const lowerQ = query.toLowerCase();
            let itemsToRender = []; 

            for(let i = 0; i < bibleLibrary.length; i++) {
                const item = bibleLibrary[i];
                if(item.title.toLowerCase().includes(lowerQ)) {
                    itemsToRender.push(item);
                }
            }
            
            // Calculate how many non-range items are currently shown
            let existingScriptureItems = container.querySelectorAll('.schedule-item:not(.range-item)').length;
            let startIndex = append ? existingScriptureItems : 0;
            let endIndex = Math.min(visibleScriptureCount.Scripture, itemsToRender.length);
            
            for(let i = startIndex; i < endIndex; i++) {
                const item = itemsToRender[i];
                
                // Check if item already exists (to avoid duplicates)
                const existingItem = container.querySelector(`[data-id="${item.id}"]`);
                if (existingItem) continue;
                
                let d = document.createElement('div'); 
                d.className = 'schedule-item'; 
                d.innerText = item.title; 
                d.draggable = true;
                d.setAttribute('data-id', item.id);
                
                d.onclick = (function(itemToPreview) {
                    return function() {
                        const content = `${itemToPreview.title}\n\n${itemToPreview.slides[0].layers[0].text}`;
                        document.getElementById('libraryPreviewText').innerText = content;
                    };
                })(item);

                d.ondblclick = (function(itemToLive) {
                    return function() {
                        goLive(itemToLive.slides[0], itemToLive);
                    };
                })(item);

                d.ondragstart = (e) => startDrag(e, 'library', -1, item); 
                container.appendChild(d);
            }
            
            if (itemsToRender.length === 0 && !append && !match) {
                container.innerHTML = "<div style='padding:20px; color:#777;'>" + 
                    (bibleLibrary.length === 0 ? 
                        "Bible not loaded. Go to File > Fetch Bible." : 
                        "No matching scriptures found.") + 
                    "</div>";
            }
            
            // Update preview text if nothing is selected
            if (!append && container.querySelectorAll('.schedule-item').length > 0) {
                const firstItem = container.querySelector('.schedule-item');
                if (firstItem) firstItem.click();
            } else if (container.querySelectorAll('.schedule-item').length === 0 && !match) {
                document.getElementById('libraryPreviewText').innerText = "Select an item to preview text...";
            }
            
            // Restore scroll position if we have one
            if (currentTabScrollPositions.Scripture > 0 && !append) {
                setTimeout(() => {
                    container.scrollTop = currentTabScrollPositions.Scripture;
                }, 10);
            }
        }

        // --- DRAG START & DROP LOGIC ---
        function startDrag(e, origin, index, itemData) {
            dragSource = origin;
            dragIndex = index;
            dragItem = itemData; 
            e.dataTransfer.effectAllowed = (origin === 'library') ? 'copy' : 'move';
            e.dataTransfer.setData('text/plain', 'valid-drag'); 
        }

        function allowDrop(e) { e.preventDefault(); }

        function dropOnSchedule(e, targetIndex) {
            e.preventDefault(); e.stopPropagation();
            if(targetIndex === undefined || targetIndex === null) targetIndex = schedule.length;

            if(dragSource === 'library' && dragItem) { 
                let clone = JSON.parse(JSON.stringify(dragItem)); 
                clone.id = Date.now(); 
                schedule.splice(targetIndex, 0, clone); 
                renderSchedule(); 
            } else if (dragSource === 'schedule') {
                if (dragIndex !== -1) {
                    let m = schedule.splice(dragIndex, 1)[0]; 
                    schedule.splice(targetIndex, 0, m); 
                    renderSchedule();
                }
            }
            resetDrag();
        }

        function dropOnLibrary(e) {
            e.preventDefault(); e.stopPropagation();
            if (dragSource === 'schedule') {
                if (currentTab === 'Song' || currentTab === 'Scripture') { resetDrag(); return; }
                if (currentTab === 'Presentation' && dragItem) {
                    let newItem = JSON.parse(JSON.stringify(dragItem));
                    newItem.id = Date.now();
                    newItem.type = 'Presentation'; 
                    library.push(newItem);
                    renderLibrary();
                    markPresentationsModified();
                    savePresentationsToStorage();
                }
            }
            resetDrag();
        }

        function resetDrag() { dragSource = null; dragIndex = -1; dragItem = null; }

        // --- RENDERERS ---
        function renderSchedule() {
            let c = document.getElementById('scheduleList'); c.innerHTML = "";
            schedule.forEach((item, i) => {
                let div = document.createElement('div'); div.className = 'schedule-item'; div.draggable = true;
                div.innerHTML = `<strong>${item.title}</strong><span style="margin-left:auto; font-size:0.7em; color:#666;">${item.type}</span>`;
                div.onclick = () => loadToGrid(item, div);
                div.oncontextmenu = (e) => showContextMenu(e, 'schedule', i, item); 
                div.ondragstart = (e) => { startDrag(e, 'schedule', i, item); };
                div.ondragover = allowDrop;
                div.ondrop = (e) => dropOnSchedule(e, i); 
                c.appendChild(div);
            });
        }

        function renderLibrary(append = false) {
            if (currentTab === 'Scripture') { 
                handleSearch(); 
                return; 
            }
            
            // Switch Preview Mode
            document.getElementById('libraryPreviewCanvas').style.display = 'block';
            document.getElementById('libraryPreviewText').style.display = 'none';

            let container = document.getElementById(`libraryList${currentTab}`); 
            if(!append) container.innerHTML = "";
            
            document.getElementById('addPresBtn').style.display = (currentTab === 'Presentation') ? 'flex' : 'none';

            const q = document.getElementById('librarySearch').value.toLowerCase();
            const filteredItems = library.filter(x => x.type === currentTab && x.title.toLowerCase().includes(q));
            
            filteredItems.forEach((item, i) => {
                let d = document.createElement('div'); 
                d.className = 'schedule-item'; 
                d.innerText = item.title; 
                d.draggable = true;
                d.setAttribute('data-id', item.id);
                
                d.onclick = () => {
                    const ctx = document.getElementById('libraryPreviewCanvas').getContext('2d');
                    const firstSlide = item.slides[0] || {text:"", layers:[]};
                    renderSlide(ctx, firstSlide, "Preview");
                };
                
                d.ondblclick = () => goLive(item.slides[0], item);
                d.oncontextmenu = e => showContextMenu(e, 'library', library.indexOf(item), item);
                d.ondragstart = (e) => startDrag(e, 'library', i, item);
                container.appendChild(d);
            });
            
            if (filteredItems.length === 0 && !append) {
                container.innerHTML = `<div style='padding:20px; color:#777;'>No ${currentTab.toLowerCase()}s found.</div>`;
            }
            
            // Restore scroll position if we have one
            if (currentTabScrollPositions[currentTab] > 0 && !append) {
                setTimeout(() => {
                    container.scrollTop = currentTabScrollPositions[currentTab];
                }, 10);
            }
        }

        function switchTab(t) { 
            // Save current scroll position before switching
            if (currentTab) {
                const currentContainer = document.getElementById(`libraryList${currentTab}`);
                if (currentContainer) {
                    currentTabScrollPositions[currentTab] = currentContainer.scrollTop;
                }
            }
            
            currentTab = t; 
            
            // Hide all tab containers and show the active one
            document.querySelectorAll('.library-list-container').forEach(container => {
                container.classList.remove('active');
            });
            document.getElementById(`${t.toLowerCase()}ListContainer`).classList.add('active');
            
            // Reset scroll position for this tab if needed
            setTimeout(() => {
                const newContainer = document.getElementById(`libraryList${t}`);
                if (newContainer && currentTabScrollPositions[t] > 0) {
                    newContainer.scrollTop = currentTabScrollPositions[t];
                }
            }, 10);
            
            const searchInput = document.getElementById('librarySearch');
            if(t === 'Scripture') {
                searchInput.setAttribute('list', 'bibleBooks');
                searchInput.placeholder = "Search Scripture (e.g. Gen 1:1)...";
            } else {
                searchInput.removeAttribute('list');
                searchInput.placeholder = "Search Library...";
            }

            searchInput.value = "";  
            
            const ctx = document.getElementById('libraryPreviewCanvas').getContext('2d');
            // Clear preview
            renderSlide(ctx, {layers:[{text:"Select Item", style:{fontSize:60}}]});

            if (t === 'Scripture') {
                renderScriptureList('', false);
            } else {
                renderLibrary(false);
            }
            
            document.querySelectorAll('.tab').forEach(x => x.classList.toggle('active', x.innerText.includes(t))); 
        }

        function loadToGrid(item, el) { 
            currentGridSlides = item.slides;
            currentSlideIdx = -1; 
            document.querySelectorAll('.schedule-item').forEach(x => x.classList.remove('selected')); 
            if(el) el.classList.add('selected'); 
            let g = document.getElementById('slideGrid'); 
            g.innerHTML = ""; 
            item.slides.forEach((slide, index) => { 
                let w = document.createElement('div'); 
                w.className = 'slide-wrapper'; 
                let cvs = document.createElement('canvas'); 
                cvs.className = 'preview-canvas'; 
                cvs.width = 1920; 
                cvs.height = 1080; 
                renderSlide(cvs.getContext('2d'), slide); 
                w.onclick = () => { 
                    currentSlideIdx = index; 
                    goLive(slide, item, w); 
                }; 
                w.appendChild(cvs); 
                g.appendChild(w); 
            }); 
        }
        
        function renderSlide(ctx, slideObj, footer="") { 
            if (!slideObj) slideObj = { layers:[] }; 
            if (slideObj.text) { slideObj.layers = [{ text: slideObj.text, style: slideObj.style || {} }]; delete slideObj.text; delete slideObj.style; } 
            if (!slideObj.layers) slideObj.layers = []; 
            
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, RESOLUTION.width, RESOLUTION.height); 
            
            const isPreview = ctx.canvas.id.includes('editor') || ctx.canvas.id.includes('library');

            if (!isPreview) {
                if (isLogo && logoImage) { 
                    let scale = Math.min(RESOLUTION.width/logoImage.width, RESOLUTION.height/logoImage.height); 
                    let w = logoImage.width * scale, h = logoImage.height * scale; 
                    ctx.drawImage(logoImage, (RESOLUTION.width-w)/2, (RESOLUTION.height-h)/2, w, h); 
                    return; 
                }
                if (isBlack) return;
            }

            if (slideObj.bgImage && !isClear) { 
                if (!slideObj._bgImgObj || slideObj._bgImgObj.src !== slideObj.bgImage) { 
                    slideObj._bgImgObj = new Image(); 
                    slideObj._bgImgObj.src = slideObj.bgImage; 
                    slideObj._bgImgObj.onload = () => { 
                        if(ctx.canvas.id.includes('editor')) renderEditorPreview(); 
                    }; 
                } 
                if (slideObj._bgImgObj.complete) { 
                    ctx.drawImage(slideObj._bgImgObj, 0, 0, RESOLUTION.width, RESOLUTION.height); 
                } 
            } 
            
            if (isClear && !isPreview) return; 
            
            slideObj.layers.forEach((layer, idx) => { 
                const style = layer.style || {}; 
                const text = layer.text || ""; 
                if (ctx.canvas.id.includes('editor') && idx === selectedLayerIndex) { 
                    ctx.save(); 
                    ctx.strokeStyle = '#007acc'; 
                    ctx.lineWidth = 2; 
                    ctx.restore(); 
                } 
                const fontSize = parseInt(style.fontSize) || 90; 
                const fontFace = style.font || "Segoe UI"; 
                const fontWeight = style.bold ? "bold" : "normal"; 
                const fontStyle = style.italic ? "italic" : "normal"; 
                const color = style.color || "white"; 
                const offX = parseInt(style.x || 0); 
                const offY = parseInt(style.y || 0); 
                ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px "${fontFace}"`; 
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle'; 
                ctx.lineJoin = "round"; 
                ctx.miterLimit = 2; 
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; 
                ctx.shadowBlur = 4; 
                ctx.shadowOffsetX = 2; 
                ctx.shadowOffsetY = 2; 
                const maxWidth = RESOLUTION.width - 200; 
                const words = text.split('\n').join(' [BR] ').split(' '); 
                let lines = [], currentLine = words[0]; 
                for (let i = 1; i < words.length; i++) { 
                    if (words[i] === '[BR]') { 
                        lines.push(currentLine); 
                        currentLine = ""; 
                        continue; 
                    } 
                    let w = ctx.measureText(currentLine + " " + words[i]).width; 
                    if (w < maxWidth) currentLine += (currentLine===""?"":" ") + words[i]; 
                    else { 
                        lines.push(currentLine); 
                        currentLine = words[i]; 
                    } 
                } 
                lines.push(currentLine); 
                let lineHeight = fontSize * 1.2; 
                let startY = (RESOLUTION.height - (lines.length * lineHeight)) / 2 + (lineHeight/2); 
                let centerX = (RESOLUTION.width/2) + offX; 
                let drawY = startY + offY; 
                lines.forEach(line => { 
                    if(line){ 
                        ctx.strokeStyle = 'black'; 
                        ctx.lineWidth = fontSize * 0.04; 
                        ctx.strokeText(line, centerX, drawY); 
                        ctx.fillStyle = color; 
                        ctx.fillText(line, centerX, drawY); 
                        drawY += lineHeight; 
                    } 
                }); 
            }); 
            if(footer && !isPreview) { 
                ctx.font = 'bold ' + (footer.includes("(KJV)") ? scriptureSettings.footerSize : 40) + 'px Arial'; 
                ctx.textAlign = 'right'; 
                ctx.fillStyle = 'rgba(255,255,255,0.7)'; 
                ctx.shadowBlur = 0; 
                ctx.fillText(footer, RESOLUTION.width-50, RESOLUTION.height-50); 
            } 
        }

        function setupEditorInteraction() { 
            const canvas = document.getElementById('editorCanvas'); 
            let isDragging = false, lastMouseX, lastMouseY; 
            canvas.addEventListener('mousedown', e => { 
                const rect = canvas.getBoundingClientRect(); 
                const scaleX = RESOLUTION.width / rect.width; 
                const scaleY = RESOLUTION.height / rect.height; 
                const mouseX = (e.clientX - rect.left) * scaleX; 
                const mouseY = (e.clientY - rect.top) * scaleY; 
                let clickedLayer = -1; 
                let minDst = 1000; 
                const slide = tempSlides[currentSlideIndex]; 
                slide.layers.forEach((layer, idx) => { 
                    const lx = (RESOLUTION.width/2) + (parseInt(layer.style?.x)||0); 
                    const ly = (RESOLUTION.height/2) + (parseInt(layer.style?.y)||0); 
                    const dst = Math.sqrt(Math.pow(mouseX-lx,2) + Math.pow(mouseY-ly,2)); 
                    if (dst < 400 && dst < minDst) { 
                        minDst = dst; 
                        clickedLayer = idx; 
                    } 
                }); 
                if(clickedLayer !== -1) { 
                    selectedLayerIndex = clickedLayer; 
                    loadLayerToToolbar(); 
                    isDragging = true; 
                    lastMouseX = e.offsetX; 
                    lastMouseY = e.offsetY; 
                    canvas.style.cursor = 'grabbing'; 
                } 
            }); 
            window.addEventListener('mousemove', e => { 
                if (!isDragging) return; 
                const rect = canvas.getBoundingClientRect(); 
                const scaleX = RESOLUTION.width / rect.width; 
                const scaleY = RESOLUTION.height / rect.height; 
                const mouseX = e.clientX - rect.left; 
                const mouseY = e.clientY - rect.top; 
                const dx = (mouseX - lastMouseX) * scaleX; 
                const dy = (mouseY - lastMouseY) * scaleY; 
                let s = tempSlides[currentSlideIndex].layers[selectedLayerIndex].style; 
                if(!s) s = {}; 
                s.x = (parseInt(s.x) || 0) + dx; 
                s.y = (parseInt(s.y) || 0) + dy; 
                tempSlides[currentSlideIndex].layers[selectedLayerIndex].style = s; 
                lastMouseX = mouseX; 
                lastMouseY = mouseY; 
                renderEditorPreview(); 
            }); 
            window.addEventListener('mouseup', () => { 
                if(isDragging) { 
                    isDragging = false; 
                    canvas.style.cursor = 'default'; 
                } 
            }); 
        }

        function openEditor(itemIndex, context) { 
            let item = context === 'schedule' ? schedule[itemIndex] : library[itemIndex]; 
            editingItem = { context, index: itemIndex, ref: item }; 
            tempSlides = item.slides.map(s => { 
                let slide = JSON.parse(JSON.stringify(s)); 
                if(slide.text) { slide.layers = [{text:slide.text, style:slide.style||{}}]; delete slide.text; delete slide.style; } 
                if(!slide.layers) slide.layers = []; 
                if(slide.layers.length===0) slide.layers.push({text:"New Text", style:{}}); 
                return slide; 
            }); 
            currentSlideIndex = 0; selectedLayerIndex = 0; 

            // Load Title
            document.getElementById('editItemTitle').value = item.title;

            const select = document.getElementById('toolFont'); select.innerHTML = ""; availableFonts.forEach(f => { let opt = document.createElement('option'); opt.value = f; opt.innerText = f; select.appendChild(opt); }); 
            document.getElementById('editorModal').style.display = 'flex'; 
            renderEditorSlideList(); 
            loadSlideToEditor(0); 
        }

        function renderEditorSlideList() { 
            const list = document.getElementById('editorSlideList'); 
            list.innerHTML = ""; 
            tempSlides.forEach((slide, i) => { 
                let div = document.createElement('div'); 
                div.className = `slide-thumb ${i === currentSlideIndex ? 'active' : ''}`; 
                let txt = slide.layers[0]?.text || "Empty"; 
                div.innerHTML = `<span class="thumb-num">${i+1}</span> <span style="font-size:0.8rem; overflow:hidden; white-space:nowrap;">${txt.substring(0,12)}...</span>`; 
                div.onclick = () => loadSlideToEditor(i); 
                list.appendChild(div); 
            }); 
        }

        function loadSlideToEditor(index) { 
            currentSlideIndex = index; 
            selectedLayerIndex = 0; 
            renderEditorSlideList(); 
            loadLayerToToolbar(); 
            renderEditorPreview(); 
        }

        function loadLayerToToolbar() { 
            const slide = tempSlides[currentSlideIndex]; 
            if(slide.layers.length === 0) { 
                document.getElementById('editorTextArea').value = ""; 
                document.getElementById('editorTextArea').disabled = true; 
                return; 
            } 
            document.getElementById('editorTextArea').disabled = false; 
            if(selectedLayerIndex >= slide.layers.length) selectedLayerIndex = 0; 
            const layer = slide.layers[selectedLayerIndex]; 
            if(!layer.style) layer.style = {}; 
            document.getElementById('toolFont').value = layer.style.font || "Segoe UI"; 
            document.getElementById('toolSize').value = layer.style.fontSize || 90; 
            document.getElementById('toolColor').value = layer.style.color || "#ffffff"; 
            document.getElementById('editorTextArea').value = layer.text; 
            document.getElementById('editorTextArea').focus(); 
        }

        function addTextBlock() { 
            tempSlides[currentSlideIndex].layers.push({ text: "New Block", style: { fontSize: 60, y: 100 } }); 
            selectedLayerIndex = tempSlides[currentSlideIndex].layers.length - 1; 
            loadLayerToToolbar(); 
            renderEditorPreview(); 
        }

        function removeCurrentBlock() { 
            const slide = tempSlides[currentSlideIndex]; 
            if(slide.layers.length <= 1) { 
                alert("Slide must have at least one block."); 
                return; 
            } 
            slide.layers.splice(selectedLayerIndex, 1); 
            selectedLayerIndex = 0; 
            loadLayerToToolbar(); 
            renderEditorPreview(); 
        }

        function updateCurrentBlockText() { 
            tempSlides[currentSlideIndex].layers[selectedLayerIndex].text = document.getElementById('editorTextArea').value; 
            renderEditorSlideList(); 
            renderEditorPreview(); 
        }

        function updateCurrentBlockStyle() { 
            let s = tempSlides[currentSlideIndex].layers[selectedLayerIndex].style; 
            s.font = document.getElementById('toolFont').value; 
            const newSize = parseInt(document.getElementById('toolSize').value);
            s.fontSize = newSize;
            s.color = document.getElementById('toolColor').value; 
            
            // Save this size to custom sizes
            addEditorSize(newSize);
            
            renderEditorPreview(); 
        }

        function toggleStyle(prop) { 
            let s = tempSlides[currentSlideIndex].layers[selectedLayerIndex].style; 
            s[prop] = !s[prop]; 
            renderEditorPreview(); 
        }

        function renderEditorPreview() { 
            renderSlide(document.getElementById('editorCanvas').getContext('2d'), tempSlides[currentSlideIndex]); 
        }

        function addNewSlide() { 
            tempSlides.push({layers:[{text:"New Slide", style:{}}]}); 
            loadSlideToEditor(tempSlides.length - 1); 
        }

        function saveEditorChanges() { 
            const newTitle = document.getElementById('editItemTitle').value.trim();
            if (newTitle) editingItem.ref.title = newTitle;
            
            editingItem.ref.slides = tempSlides; 
            if(editingItem.context === 'schedule') renderSchedule(); else renderLibrary(); 
            document.getElementById('editorModal').style.display = 'none'; 
            showToast(`Item "${editingItem.ref.title}" updated.`);
            
            // If this was a presentation, mark as modified and save to storage
            if (editingItem.ref.type === 'Presentation') {
                markPresentationsModified();
                savePresentationsToStorage();
            }
        }

        function closeEditor() { 
            document.getElementById('editorModal').style.display = 'none'; 
        }

        function uploadSlideBG(input) { 
            if(input.files && input.files[0]){ 
                let r = new FileReader(); 
                r.onload = e => { 
                    tempSlides[currentSlideIndex].bgImage = e.target.result; 
                    renderEditorPreview(); 
                }; 
                r.readAsDataURL(input.files[0]); 
            } 
        }

        function clearSlideBG() { 
            delete tempSlides[currentSlideIndex].bgImage; 
            renderEditorPreview(); 
        }

        function createNewPresentation() { 
            let newItem = { 
                id: Date.now(), 
                title: "New Presentation", 
                type: "Presentation", 
                slides: [{layers:[{text:"Title Slide", style:{fontSize:90}}]}] 
            }; 
            library.push(newItem); 
            renderLibrary(); 
            markPresentationsModified();
            savePresentationsToStorage();
            openEditor(library.length - 1, 'library'); 
        }

        function fetchGoogleFont() { 
            const nameInput = document.getElementById('googleFontName');
            const name = nameInput.value.trim();
            const status = document.getElementById('fontStatus');
            if(!name) return;
            status.innerText = "Fetching...";
            status.style.color = "#bbb";
            const link = document.createElement('link');
            link.href = `https://fonts.googleapis.com/css?family=${name.replace(/ /g, '+')}&display=swap`;
            link.rel = 'stylesheet';
            link.onload = () => {
                addFontOption(name);
                status.innerText = `Success! "${name}" added.`;
                status.style.color = "#4caf50";
                nameInput.value = "";
                renderFontList();
                
                // Update projector window if open
                if (projectorWindow && !projectorWindow.closed) {
                    try {
                        const newLink = projectorWindow.document.createElement('link');
                        newLink.href = link.href;
                        newLink.rel = 'stylesheet';
                        projectorWindow.document.head.appendChild(newLink);
                    } catch(e) {
                        console.log("Failed to update projector with Google Font:", e);
                    }
                }
                
                setTimeout(() => {
                    document.getElementById('fontManager').style.display = 'none';
                    status.innerText = "";
                }, 1000);
            };
            link.onerror = () => {
                status.innerText = `Error: Font "${name}" not found.`;
                status.style.color = "#d32f2f";
            };
            document.head.appendChild(link);
        }

        function uploadLocalFont(input) {
            if(input.files && input.files[0]) {
                const status = document.getElementById('fontStatus');
                status.innerText = "Loading file...";
                status.style.color = "#bbb";
                const file = input.files[0];
                const reader = new FileReader();
                reader.onload = (e) => {
                    const fontName = file.name.split('.')[0];
                    const arrayBuffer = e.target.result;
                    const base64 = arrayBufferToBase64(arrayBuffer);
                    const dataURL = `data:font/opentype;base64,${base64}`;
                    
                    // Store font data for projector window
                    localFontData[fontName] = dataURL;

                    const fontFace = new FontFace(fontName, `url(${dataURL})`);
                    fontFace.load().then(loadedFace => {
                        document.fonts.add(loadedFace);
                        addFontOption(fontName);
                        status.innerText = `Success! "${fontName}" loaded.`;
                        status.style.color = "#4caf50";
                        input.value = "";
                        renderFontList();
                        
                        // Update projector window if open
                        if (projectorWindow && !projectorWindow.closed) {
                            try {
                                const style = projectorWindow.document.createElement('style');
                                style.textContent = `@font-face { font-family: "${fontName}"; src: url(${dataURL}); }`;
                                projectorWindow.document.head.appendChild(style);
                            } catch(e) {
                                console.log("Failed to update projector fonts:", e);
                            }
                        }
                        
                        setTimeout(() => {
                            document.getElementById('fontManager').style.display = 'none';
                            status.innerText = "";
                        }, 1000);
                    }).catch(err => {
                        status.innerText = "Failed to load font file.";
                        status.style.color = "#d32f2f";
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function addFontOption(name) { 
            if(!availableFonts.includes(name)) { 
                availableFonts.push(name); 
                const select = document.getElementById('toolFont'); 
                if(select) { 
                    let exists = false; 
                    for(let i=0; i<select.options.length; i++) { 
                        if(select.options[i].value === name) { 
                            exists = true; 
                            break; 
                        } 
                    } 
                    if(!exists) { 
                        const opt = document.createElement('option'); 
                        opt.value = name; 
                        opt.innerText = name; 
                        select.appendChild(opt); 
                    } 
                } 
            } 
        }

        function renderFontList() { 
            const list = document.getElementById('installedFontsList'); 
            list.innerHTML = ""; 
            availableFonts.forEach(font => { 
                const div = document.createElement('div'); 
                div.className = 'font-list-item'; 
                div.innerText = font; 
                div.style.fontFamily = font; 
                list.appendChild(div); 
            }); 
        }

        function compressImage(base64Str) { 
            return new Promise((resolve) => { 
                const img = new Image(); 
                img.src = base64Str; 
                img.onload = () => { 
                    const canvas = document.createElement('canvas'); 
                    const ctx = canvas.getContext('2d'); 
                    canvas.width = 1920; 
                    canvas.height = 1080; 
                    ctx.drawImage(img, 0, 0, 1920, 1080); 
                    resolve(canvas.toDataURL('image/jpeg', 0.8)); 
                }; 
                img.onerror = () => resolve(null); 
            }); 
        }

        async function saveSchedule() { 
            if(schedule.length === 0) { 
                showToast("Schedule is empty!"); 
                return; 
            } 
            document.body.style.cursor = 'wait'; 
            let exportData = JSON.parse(JSON.stringify(schedule)); 
            for (let item of exportData) { 
                for (let slide of item.slides) { 
                    if (slide.bgImage) { 
                        const compressed = await compressImage(slide.bgImage); 
                        if (compressed) slide.bgImage = compressed; 
                    } 
                } 
            } 
            const blob = new Blob([JSON.stringify(exportData)], {type: "application/json"}); 
            const url = URL.createObjectURL(blob); 
            const a = document.createElement('a'); 
            a.href = url; 
            a.download = `Service_${new Date().toISOString().slice(0,10)}.schedule`; 
            document.body.appendChild(a); 
            a.click(); 
            document.body.removeChild(a); 
            URL.revokeObjectURL(url); 
            document.body.style.cursor = 'default'; 
            showToast("Schedule Saved!"); 
        }

        function handleScheduleLoad(input) { 
            if (input.files[0]) { 
                let r = new FileReader(); 
                r.onload = e => { 
                    try { 
                        let data = JSON.parse(e.target.result); 
                        if(Array.isArray(data)) { 
                            schedule = data; 
                            renderSchedule(); 
                            showToast("Schedule Loaded Successfully!"); 
                        } else { 
                            showToast("Invalid Schedule File"); 
                        } 
                    } catch(err) { 
                        showToast("Error parsing schedule file."); 
                    } 
                }; 
                r.readAsText(input.files[0]); 
            } 
        }
        
        function handleContentLoad(input) {
            const file = input.files[0];
            if (!file) return;

            const fileName = file.name.toLowerCase();
            const isHymn = fileName.endsWith('.hymn');
            const isBible = fileName.endsWith('.bible');
            
            if (!isHymn && !isBible && !fileName.endsWith('.json')) {
                showToast("Please select a valid .bible, .hymn, or .json file.");
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!Array.isArray(data)) throw new Error("Invalid format structure");
                    
                    if (isBible) {
                        bibleLibrary = data;
                        if (currentTab === 'Scripture') renderLibrary();
                        showToast(`Loaded ${data.length} scriptures!`);
                    } else if (isHymn || (fileName.endsWith('.json') && data.every(item => item.type === 'Song' || item.type === 'Presentation'))) {
                        const newItems = data.filter(item => item.type === 'Song' || item.type === 'Presentation');
                        library = [...library, ...newItems];
                        if (currentTab === 'Song' || currentTab === 'Presentation') renderLibrary();
                        showToast(`Loaded ${newItems.length} songs/hymns!`);
                        
                        // If presentations were loaded, save them to storage
                        const presentationCount = newItems.filter(item => item.type === 'Presentation').length;
                        if (presentationCount > 0) {
                            markPresentationsModified();
                            savePresentationsToStorage();
                        }
                    } else {
                        showToast("Could not determine content type. Loaded nothing.");
                    }

                } catch (err) {
                    showToast("Error reading file: " + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        function showContextMenu(e, context, index, item) { 
            e.preventDefault(); 
            rightClickedItem = { context, index, item }; 
            const menu = document.getElementById('contextMenu'); 
            menu.style.display = 'block'; 
            menu.style.left = e.pageX + 'px'; 
            menu.style.top = e.pageY + 'px'; 
            
            const rmvBtn = document.getElementById('ctxRemove');
            const renameBtn = document.getElementById('ctxRename');

            if (context === 'schedule') { 
                rmvBtn.style.display = 'block'; 
            } else if (context === 'library' && item.type === 'Presentation') {
                rmvBtn.style.display = 'block'; 
            } else {
                rmvBtn.style.display = 'none';
            }
            renameBtn.style.display = 'block';
            
            renameBtn.onclick = () => {
                menu.style.display = 'none';
                let sourceArray = (context === 'schedule') ? schedule : library;
                const sourceIndex = sourceArray.findIndex(i => i.id === item.id);
                if (sourceIndex !== -1) openEditor(sourceIndex, context);
            };
        }

        document.getElementById('ctxRemove').onclick = () => { 
            if (rightClickedItem.context === 'schedule') { 
                schedule.splice(rightClickedItem.index, 1); 
                renderSchedule(); 
            } else if (rightClickedItem.context === 'library') { 
                // If removing a presentation, mark as modified
                if (rightClickedItem.item.type === 'Presentation') {
                    markPresentationsModified();
                }
                
                library.splice(rightClickedItem.index, 1); 
                renderLibrary();
                
                // Save presentations to storage if one was removed
                if (rightClickedItem.item.type === 'Presentation') {
                    savePresentationsToStorage();
                }
            } 
            document.getElementById('contextMenu').style.display = 'none'; 
        };

        document.getElementById('ctxEdit').onclick = () => { 
             let idx = rightClickedItem.index; 
             if(rightClickedItem.context === 'library') idx = library.findIndex(i => i.id === rightClickedItem.item.id);
             openEditor(idx, rightClickedItem.context); 
        };

        function openFontManager() { 
            document.getElementById('fontManager').style.display='flex'; 
            document.getElementById('fontStatus').innerText=''; 
            renderFontList(); 
        }
        
        function processFetchedData(data, fileName, extension, type) {
            const temp = JSON.stringify(data);
            const msgBox = document.getElementById('saveAlertModal').querySelector('h3');
            
            msgBox.innerText = `${type} Fetched!`;
            
            document.getElementById('saveMsg').innerHTML = `Successfully fetched ${data.length} ${type.toLowerCase()} items. Please save this <strong>.${extension}</strong> file to your computer.`;

            document.getElementById('saveAlertModal').style.display = 'flex';
            
            const saveBtn = document.getElementById('btnSaveDisk');
            const newBtn = saveBtn.cloneNode(true);
            saveBtn.parentNode.replaceChild(newBtn, saveBtn);
            newBtn.innerText = `Save .${extension} File`;

            newBtn.onclick = () => {
                const blob = new Blob([temp], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = fileName + '.' + extension;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                document.getElementById('saveAlertModal').style.display = 'none';
                showToast(`Saved ${type} to disk.`);
            };
        }

        function downloadBibleFromWeb() { 
            const statusLabel = document.getElementById('projStatus');
            statusLabel.innerText = "FETCHING BIBLE..."; statusLabel.style.color = "orange";
            fetch('https://raw.githubusercontent.com/thiagobodruk/bible/master/json/en_kjv.json')
                .then(r => r.json())
                .then(data => {
                    let newBibleLibrary = []; 
                    let idCounter = 10000;
                    if(Array.isArray(data) && data[0].chapters) {
                        data.forEach(book => {
                            book.chapters.forEach((chapter, cIdx) => {
                                chapter.forEach((verse, vIdx) => {
                                    newBibleLibrary.push({ 
                                        id: idCounter++, 
                                        title: `${book.name} ${cIdx+1}:${vIdx+1}`, 
                                        type: "Scripture", 
                                        slides: [{layers:[{text:verse, style:{fontSize:90}}]}] 
                                    });
                                });
                            });
                        });
                        statusLabel.innerText = "OFFLINE"; statusLabel.style.color = "#d32f2f";
                        processFetchedData(newBibleLibrary, 'OpenWorship_KJV', 'bible', 'Bible');
                    } else throw new Error("Invalid format");
                })
                .catch(e => showToast("Download Failed: " + e.message));
        }

        // --- HYMN FETCH IMPLEMENTATION ---
        function downloadHymnsFromWeb() {
            const statusLabel = document.getElementById('projStatus');
            statusLabel.innerText = "FETCHING HYMNS..."; statusLabel.style.color = "orange";

            // Mock Data Generation (Reliable Public Domain Hymns)
            let hymns = [
                {title: "Amazing Grace", verses: ["Amazing Grace! how sweet the sound, That saved a wretch like me! I once was lost, but now am found, Was blind, but now I see."], chorus: ["Amazing Grace, amazing love, Reaching from heaven above."]},
                {title: "Holy, Holy, Holy", verses: ["Holy, holy, holy! Lord God Almighty! Early in the morning our song shall rise to Thee; Holy, holy, holy, merciful and mighty! God in three Persons, blessed Trinity!"], chorus: [""]},
                {title: "It Is Well With My Soul", verses: ["When peace, like a river, attendeth my way, When sorrows like sea billows roll; Whatever my lot, Thou hast taught me to say, It is well, it is well, with my soul."], chorus: ["It is well, with my soul, It is well, it is well, with my soul."]},
            ];
            
            let formattedHymns = [];
            let idCounter = 20000;

            hymns.forEach(h => {
                let slides = [];
                h.verses.forEach(verse => slides.push({ layers: [{ text: verse.replace(/, /g, ',\n'), style: {fontSize: 80} }] }));
                if (h.chorus[0] && h.chorus[0] !== "") {
                    slides.unshift({ layers: [{ text: h.chorus.join('\n').replace(/, /g, ',\n'), style: {fontSize: 85, color:"#FFFF00"} }] }); 
                }
                
                formattedHymns.push({
                    id: idCounter++,
                    title: h.title,
                    type: "Song",
                    slides: slides
                });
            });

            statusLabel.innerText = "OFFLINE"; statusLabel.style.color = "#d32f2f";
            processFetchedData(formattedHymns, 'OpenWorship_HymnPack', 'hymn', 'Hymns');
        }

        init();
    </script>
</body>
</html>
